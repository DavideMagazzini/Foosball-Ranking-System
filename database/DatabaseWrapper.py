from pymongo import MongoClient
from pymongo.results import InsertOneResult
import datetime
from models.game import Game
from models.player import Player
from models.score import Score
from dataclasses import asdict
from bson import ObjectId

class DatabaseWrapper():
    def __init__(self):
        uri = "mongodb+srv://wolfreverse:4jge5145s6iQ9p0j@frscluster.jsuqmkw.mongodb.net/?retryWrites=true&w=majority&appName=Frscluster"
        self.client = MongoClient(uri)

        # Access the database
        self.db = self.client["Frs_db"]

        # Get the collections
        self.players = self.db['Players']
        self.games = self.db['Games']


    def addPlayer(self, player: Player):
        """
        Adds a new player to the database.

        Parameters
        ----------
        player : Player
            The player object to add to the database.
        """
        new_entry = asdict(player)
        if not new_entry.get('_id'):
            new_entry.pop('_id', None)  # Remove _id if it exists, as it will be auto-generated by MongoDB
        # Insert the player
        result = self.players.insert_one(new_entry)
        return result

    def updatePlayerScore(self, player: Player, new_score: Score, isDefScore: bool = True) -> dict:
        """
        Update the player's scores, the new one and the old one, in the database.

        Parameters
        ----------
        player : Player
            The player whose score is to be updated.
        new_score : Score
            The new score to be set for the player.
        isDefScore : bool, optional
            If True, updates the defensive score; if False, updates the attacking score. Defaults to True.

        Returns
        -------
        dict
            The result of the update operation.
        """

        filter = {
            '_id': player._id
        }
        
        if isDefScore:
            new_score = {
                '$set': {'def_score.mu': new_score.mu,
                         'def_score.sigma': new_score.sigma,
                         'def_score.rank': new_score.rank,
                         'prev_def_score.mu': player.def_score.mu,
                         'prev_def_score.sigma': player.def_score.sigma,
                         'prev_def_score.rank': player.def_score.rank}
            }
        else:
            new_score = {
                '$set': {'atk_score.mu': new_score.mu,
                         'atk_score.sigma': new_score.sigma,
                         'atk_score.rank': new_score.rank,
                         'prev_atk_score.mu': player.atk_score.mu,
                         'prev_atk_score.sigma': player.atk_score.sigma,
                         'prev_atk_score.rank': player.atk_score.rank}
            }

        res = self.players.find_one_and_update(filter=filter, update=new_score)

        return res


    def addGame(self, game: Game) -> InsertOneResult:
        """
        Adds a new game to the database.

        Parameters
        ----------
        game : Game
            The game object to add to the database.

        Returns
        -------
        InsertOneResult
            The result of the insert operation.
        """

        new_entry = asdict(game)
        # Insert the game
        result = self.games.insert_one(new_entry)
        return result

    
    def getGameById(self, game_id: str | ObjectId) -> Game:
        """
        Retrieves a game from the database by its unique identifier.

        Parameters
        ----------
        game_id : str | ObjectId
            The unique identifier of the game to retrieve.

        Returns
        -------
        Game
            The game class corresponding to the given ID, or None if not found.
        """

        return self.games.find_one({'_id': game_id})

    def getPlayerById(self, player_id: str | ObjectId) -> Player:
        """
        Retrieves a player from the database by its unique identifier.

        Args:
            player_id (str | ObjectId): The unique identifier of the player to retrieve.

        Returns:
            Player: The player class corresponding to the given ID, or None if not found.
        """
        if isinstance(player_id, str):
            player_id = ObjectId(player_id)
        return self.players.find_one({'_id': player_id})
    
    def getAllPlayers(self):
        """
        Retrieves all player records from the database.

        Returns:
            pymongo.cursor.Cursor: A cursor to iterate over all player documents.
        """
        return self.players.find({})
    

    def getAllGames(self):
        """
        Retrieves all game records from the database.

        Returns:
            pymongo.cursor.Cursor: A cursor to iterate over all game documents.
        """
        return self.games.find({})


    def removeGameById(self, game_id: str | ObjectId):
        """
        Removes a game from the database by its unique identifier.

        Parameters
        ----------
        game_id : str | ObjectId
            The unique identifier of the game to remove.

        Returns
        -------
        dict
            The result of the delete operation.
        """

        return self.games.delete_one({'_id': game_id})
    

    def removeGameAndUpdateScores(self, game: Game):
        """
        Removes a game from the database and updates the scores of the players involved in the game.

        Parameters
        ----------
        game : Game
            The game object to remove and whose players' scores are to be updated.

        Returns
        -------
        dict
            The result of the delete operation.
        """
        #TODO think about what happens to prev def score and if its ok

        # Update red player's defensive score
        self.updatePlayerScore(game.redDefPlayer, game.redDefPlayer.prev_def_score, isDefScore=True)
        
        # Update red player's attacking score
        self.updatePlayerScore(game.redAtkPlayer, game.redAtkPlayer.prev_atk_score, isDefScore=False)
        
        # Update blue player's defensive score
        self.updatePlayerScore(game.blueDefPlayer, game.blueDefPlayer.prev_def_score, isDefScore=True)
        
        # Update blue player's attacking score
        self.updatePlayerScore(game.blueAtkPlayer, game.blueAtkPlayer.prev_atk_score, isDefScore=False)

        # Remove the game from the database
        return self.removeGameById(game._id)
    

    def getPlayerScoreHistory(self, playerId: str | ObjectId) -> list[list[Score]]:
        """
        Retrieves the score history of a player by their unique identifier.
        
        Parameters
        ----------
        playerId : str | ObjectId
            The unique identifier of the player whose score history is to be retrieved.
            
        Returns
        -------
        two lists of Score
            The first list contains the defensive score history, 
            and the second list contains the attacking score history.
        """

        if isinstance(playerId, str):
            playerId = ObjectId(playerId)

        # Find all games where the player participated
        games = self.games.find({
            '$or': [
                {'redDefPlayer._id': playerId},
                {'redAtkPlayer._id': playerId},
                {'blueDefPlayer._id': playerId},
                {'blueAtkPlayer._id': playerId}
            ]
        }).sort('date', 1)

        # score_history = []
        # for game in games:
        #     score_history.append(Score(
        #         mu=game['redDefPlayer']['def_score']['mu'] if game['redDefPlayer']['_id'] == playerId else))



if __name__ == '__main__':
    
    player1 = Player('1', 'asda', 'asdn')
    player2 = Player('123123', 'Coso', 'Dei cosis', 100, 20)
    player3 = Player('fgh', 'Maremma', 'Maiala', 2100, 20)
    player4 = Player('kasn', 'Puttana', 'Troia', 1002, 2011)

    game = Game('12', datetime.datetime.now(), player1, player3, player2, player4, 'red')
    db_wrapper = DatabaseWrapper()

    print(db_wrapper.getPlayerById('s'))

