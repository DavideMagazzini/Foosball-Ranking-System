from pymongo import MongoClient
from pymongo.results import InsertOneResult
from datetime import datetime, timezone
from models.game import Game
from models.player import Player
from models.score import Score
from models.stats import Stats
from models.achievement import Achievement
from dataclasses import asdict
from bson import ObjectId

class DatabaseWrapper():
    def __init__(self):
        uri = "mongodb+srv://wolfreverse:4jge5145s6iQ9p0j@frscluster.jsuqmkw.mongodb.net/?retryWrites=true&w=majority&appName=Frscluster"
        self.client = MongoClient(uri)

        # Access the database
        self.db = self.client["Frs_db"]

        # Get the collections
        self.players = self.db['Players']
        self.games = self.db['Games']
        self.achievements = self.db['Achievements']
        self.player_achievements = self.db['Player_Achievements']


    def addPlayer(self, player: Player):
        """
        Adds a new player to the database.

        Parameters
        ----------
        player : Player
            The player object to add to the database.
        """
        new_entry = asdict(player)
        if not new_entry.get('_id'):
            new_entry.pop('_id', None)  # Remove _id if it exists, as it will be auto-generated by MongoDB
        # Insert the player
        result = self.players.insert_one(new_entry)
        return result

    def updatePlayerScore(self, player: Player, new_score: Score, new_prev_score: Score = None, isDefScore: bool = True) -> dict:
        """
        Update the player's scores, the new one and the old one, in the database.

        Parameters
        ----------
        player : Player
            The player whose score is to be updated.
        new_score : Score
            The new score to be set for the player.
        new_prev_score : Score, optional
            The previous score to be set for the player. If nothing is passed, it gets automatically
            copied from the actual score.
        isDefScore : bool, optional
            If True, updates the defensive score; if False, updates the attacking score. Defaults to True.

        Returns
        -------
        dict
            The result of the update operation.
        """

        filter = {
            '_id': player._id
        }


        if isDefScore:
            new_score = {
                '$set': {'def_score.mu': new_score.mu,
                         'def_score.sigma': new_score.sigma,
                         'def_score.rank': new_score.rank,
                         'prev_def_score.mu': new_prev_score if new_prev_score else player.def_score.mu,
                         'prev_def_score.sigma': new_prev_score if new_prev_score else player.def_score.sigma,
                         'prev_def_score.rank': new_prev_score if new_prev_score else player.def_score.rank}
            }
        else:
            new_score = {
                '$set': {'atk_score.mu': new_score.mu,
                         'atk_score.sigma': new_score.sigma,
                         'atk_score.rank': new_score.rank,
                         'prev_atk_score.mu': new_prev_score if new_prev_score else player.atk_score.mu,
                         'prev_atk_score.sigma': new_prev_score if new_prev_score else player.atk_score.sigma,
                         'prev_atk_score.rank': new_prev_score if new_prev_score else player.atk_score.rank}
            }

        res = self.players.find_one_and_update(filter=filter, update=new_score)

        return res


    def addGame(self, game: Game) -> InsertOneResult:
        """
        Adds a new game to the database.

        Parameters
        ----------
        game : Game
            The game object to add to the database.

        Returns
        -------
        InsertOneResult
            The result of the insert operation.
        """

        new_entry = asdict(game)
        # Insert the game
        result = self.games.insert_one(new_entry)
        return result

    
    def getGameById(self, game_id: str | ObjectId) -> Game:
        """
        Retrieves a game from the database by its unique identifier.

        Parameters
        ----------
        game_id : str | ObjectId
            The unique identifier of the game to retrieve.

        Returns
        -------
        Game
            The game class corresponding to the given ID, or None if not found.
        """

        return self.games.find_one({'_id': game_id})

    def getPlayerById(self, player_id: str | ObjectId) -> Player:
        """
        Retrieves a player from the database by its unique identifier.

        Args:
            player_id (str | ObjectId): The unique identifier of the player to retrieve.

        Returns:
            Player: The player class corresponding to the given ID, or None if not found.
        """
        if isinstance(player_id, str):
            player_id = ObjectId(player_id)
        return Player(**self.players.find_one({'_id': player_id}))
    
    def getAllPlayers(self):
        """
        Retrieves all player records from the database.

        Returns:
            pymongo.cursor.Cursor: A cursor to iterate over all player documents.
        """
        return self.players.find({})
    

    def getAllGames(self):
        """
        Retrieves all game records from the database.

        Returns:
            pymongo.cursor.Cursor: A cursor to iterate over all game documents.
        """
        return self.games.find({})


    def removeGameById(self, game_id: str | ObjectId) -> dict:
        """
        Removes a game from the database by its unique identifier.

        Parameters
        ----------
        game_id : str | ObjectId
            The unique identifier of the game to remove.

        Returns
        -------
        dict
            The result of the delete operation.
        """

        return self.games.delete_one({'_id': game_id})
    

    def removeGameAndUpdateScores(self, game: Game) -> dict:
        """
        Removes a game from the database and updates the scores of the players involved in the game.

        Parameters
        ----------
        game : Game
            The game object to remove and whose players' scores are to be updated.

        Returns
        -------
        dict
            The result of the delete operation.
        """
        # 1. Update all the 4 player's scores with the scores that they had when they
        #    played that game.
        # 2. Delete the game from the database

        # Update red player's defensive score
        self.updatePlayerScore(game.redDefPlayer, new_score=game.redDefPlayer.def_score, 
                               new_prev_score=game.redDefPlayer.prev_def_score, isDefScore=True)
        
        # Update red player's attacking score
        self.updatePlayerScore(game.redAtkPlayer, new_score=game.redAtkPlayer.atk_score, 
                               new_prev_score=game.redAtkPlayer.prev_atk_score, isDefScore=False)
        
        # Update blue player's defensive score
        self.updatePlayerScore(game.blueDefPlayer, new_score=game.blueDefPlayer.def_score,
                               new_prev_score=game.blueDefPlayer.prev_def_score, isDefScore=True)
        
        # Update blue player's attacking score
        self.updatePlayerScore(game.blueAtkPlayer, new_score=game.blueAtkPlayer.atk_score, 
                               new_prev_score=game.blueAtkPlayer.prev_atk_score, isDefScore=False)

        # Remove the game from the database
        return self.removeGameById(game._id)
    

    def getPlayerScoreHistory(self, playerId: str | ObjectId) -> list[list[Score]]:
        """
        Retrieves the defense and attack score history of a player by their unique identifier.
        
        Parameters
        ----------
        playerId : str | ObjectId
            The unique identifier of the player whose score history is to be retrieved.
            
        Returns
        -------
        two lists of Score
            The first list contains the defensive score history, 
            and the second list contains the attacking score history.
        """

        if isinstance(playerId, str):
            playerId = ObjectId(playerId)

        # Find all games where the player participated
        games = self.games.find({
            '$or': [
                {'redDefPlayer._id': playerId},
                {'redAtkPlayer._id': playerId},
                {'blueDefPlayer._id': playerId},
                {'blueAtkPlayer._id': playerId}
            ]
        }).sort('date', 1)

        def_score_history = []
        atk_score_history = []

        for game in games:
            if game['redDefPlayer']['_id'] == playerId:
                # The player was playing red defense
                def_score_history.append(Score(**game['redDefPlayer']['def_score']))
            elif game['redAtkPlayer']['_id'] == playerId:
                # The player was playing red attack
                atk_score_history.append(Score(**game['redAtkPlayer']['atk_score']))
            elif game['blueDefPlayer']['_id'] == playerId:
                # The player was playing blue defense
                def_score_history.append(Score(**game['blueDefPlayer']['def_score']))
            elif game['blueAtkPlayer']['_id'] == playerId:
                # The player was playing blue attack
                atk_score_history.append(Score(**game['blueAtkPlayer']['atk_score']))
        
        # Append last scores of the player
        def_score_history.append(self.getPlayerById(playerId).def_score)
        atk_score_history.append(self.getPlayerById(playerId).atk_score)


        return [def_score_history, atk_score_history]
    

    def getAllAchievements(self):
        """
        Retrieves all the achievements from the database.
 
        Returns
        -------
        pymongo.cursor.Cursor
            A cursor to iterate over all achievements documents.
        """

        # return [Achievement(**doc) for doc in self.achievements.find({})] # SLOWS DOWN COMPUTATION
        return self.achievements.find({})
    

    def updatePlayerStats(self, playerId: str | ObjectId, new_stats: Stats) -> dict:
        """
        Updates, in the database, given player stats with the new stats.

        Parameters
        ----------
        playerId : str | ObjectId
            The unique identifier of the player whose score history is to be retrieved.
        new_stats: Stats
            The new stats that will replace the player stats.
            
        Returns
        -------
        dict
            The result of the update operation.
        """
        if isinstance(playerId, str):
            playerId = ObjectId(playerId)

        self.players.update_one({'_id': playerId}, {'$set': {'stats': asdict(new_stats)}})

    
    def unlockPlayerAchievement(self, playerAchievementId: str | ObjectId, unlocked: bool = True) -> dict:
        """
        Unlock/Locks a player achievement by setting its unlocked state to what is passed. The default is unlocked = True.
        The unlocked_date get also updated with the current time.

        Parameters
        ----------
        playerAchievementId : str | ObjectId
            The unique identifier of the player achievement whose unlocked state has to be updated.
        unlocked: bool
            The unlocked state of the player achievement. The default is True.
            
        Returns
        -------
        dict
            The result of the update operation.
        """
        if isinstance(playerAchievementId, str):
            playerAchievementId = ObjectId(playerAchievementId)

        self.player_achievements.update_one({'_id': playerAchievementId}, {'$set': {'unlocked': unlocked, 'unlocked_date': datetime.now(timezone.utc)}})



if __name__ == '__main__':
    
    db_wrapper = DatabaseWrapper()
    
    achs = db_wrapper.getAllAchievements()